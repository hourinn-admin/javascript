<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LHS查询与RHS查询</title>
</head>
<body>
  <article>
    <p>编译器生成了可执行的代码,引擎在执行它时，会通过查找变量a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。</p>
    <p><code>var a = 2;</code> 引擎会为变量a 进行LHS 查询。另外一个查找的类型叫作RHS。</p>

    <h3>“L”和“R”的含义，它们分别代表左侧和右侧。</h3>
    <p>什么东西的左侧和右侧？是一个赋值操作的左侧和右侧。LHS 和RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最
      好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。</p>
    
    <h3>考虑下面的程序，其中既有LHS 也有RHS 引用：</h3>
    <pre><code>
      function foo(a) {
        console.log( a ); // 2
      }
      foo( 2 );
    </code></pre>

    <h4>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</h4>
    <pre>
      引擎：我说作用域，我需要为foo 进行RHS 引用。你见过它吗？
      作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
      引擎：哥们太够意思了！好吧，我来执行一下foo。
      引擎：作用域，还有个事儿。我需要为a 进行LHS 引用，这个你见过吗？
      作用域：这个也见过，编译器最近把它声名为foo 的一个形式参数了，拿去吧。
      引擎：大恩不言谢，你总是这么棒。现在我要把2 赋值给a。
      引擎：哥们，不好意思又来打扰你。我要为console 进行RHS 引用，你见过它吗？
      作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。
      给你。
      引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。
      引擎：哥们，能帮我再找一下对a 的RHS 引用吗？虽然我记得它，但想再确认一次。
      作用域：放心吧，这个变量没有变动过，拿走，不谢。
      引擎：真棒。我来把a 的值，也就是2，传递进log(..)。</pre>
  </article>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>词法作用域</title>
</head>
<body>
  <article>
    <h3>词法作用域</h3>
    <p>大部分标准语言编译器的第一个工作阶段叫作词法化,而词法作用域就是定义在词法阶段的作用域,换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域
      不变（大部分情况下是这样的）</p>
    
    <p><b>考虑以下代码：</b><br>
      
      <pre><code>
        function foo(a) {
          var b = a * 2;
          function bar(c) {
            console.log( a, b, c );
          }
          bar( b * 3 );
        }
        foo( 2 ); // 2, 4, 12
      </code></pre>
    </p>
    <p>在这个例子中有三个逐级嵌套的作用域:</p>
    <ol>
      <li>包含着整个全局作用域，其中只有一个标识符：foo。</li>
      <li>包含着foo 所创建的作用域，其中有三个标识符：a、bar 和b。</li>
      <li>包含着bar 所创建的作用域，其中只有一个标识符：c。</li>
    </ol>
    <p>在上一个代码片段中，引擎执行console.log(..) 声明，并查找a、b 和c 三个变量的引用。它首先从最内部的作用域，也就是bar(..) 函数的作用域气泡开始查找。
      引擎无法在这里找到a，因此会去上一级到所嵌套的foo(..) 的作用域中继续查找。在这里找到了a， 因此引擎使用了这个引用。
      对b 来讲也是一样的。而对c 来说，引擎在bar(..) 中就找到了它。</p>

  </article>
 
</body>
</html>
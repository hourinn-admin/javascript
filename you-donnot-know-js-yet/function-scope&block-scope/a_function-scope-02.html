<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>函数中的作用域的特点</title>
  <style>
    .left {
        float: left;
        width: 800px;
        height: 200px;
        background-color: gray;
      }
    .right {
      background-color: gray;
      margin-left: 850px;
      height: 200px;
    }
    .code {
        width: 800px;
        height: 200px;
        background-color: gray;
      }
  </style>
</head>
<body>
  <article>
    <h3>隐藏内部实现</h3>
    <p>声明一个函数的实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任<br>
      何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的<br>
      作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域<br>
      来“隐藏”它们。</p>

      <h3>最小暴露原则</h3>
      <p>这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来。如下面代码所示：</p>
      <div class="left">
        <pre>
          <code>
            function doSomething(a) {
              b = a + doSomethingElse( a * 2 );
              console.log( b * 3 );
            }
            function doSomethingElse(a) {
              return a - 1;
            }
            var b;
            doSomething( 2 ); // 15
          </code>
        </pre>
      </div>
      <div style="float: left;">=></div>
      <div class="right">
        <pre>
          <code>
            function doSomething(a) {
              function doSomethingElse(a) {
                return a - 1;
              }
              var b;
              b = a + doSomethingElse( a * 2 );
              console.log( b * 3 );
            }
            doSomething( 2 ); // 15
          </code>
        </pre>
      </div>

      <h3>规避冲突</h3>
      <p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突,如下代码所示：</p>

      <div class="left">
        <pre>
          <code>
            function foo() {
              function bar(a) {
                i = 3;         // 修改for 循环所属作用域中的i
                console.log( a + i );
              }
              for (var i=0; i<10; i++) {
                bar( i * 2 );  // 糟糕，无限循环了！
              }
            }
            foo();
          </code>
        </pre>
      </div>
      <div style="float: left;">=></div>
      <div class="right">
        <pre>
          <code>
            function foo() {
              function bar(a) {
                var i = 3;         // 需要声明一个本地变量来使用,采用任何名字都可以
                console.log( a + i );
              }
              for (var i=0; i<10; i++) {
                bar( i * 2 );   
              }
            }
            foo();
          </code>
        </pre>
      </div>

      <h5>全局命名空间</h5>
      <p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它<br>
        们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</p>
      <p>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象<br>
        被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属<br>
        性，而不是将自己的标识符暴露在顶级的词法作用域中。如下代码所示:</p>
      <div class="code">
        <pre>
          <code>
            var MyReallyCoolLibrary = {
              awesome: "stuff",
              doSomething: function() {
              // ...
              },
              doAnotherThing: function() {
              // ...
              }
            };
          </code>
        </pre>
      </div>
      <h5>模块管理</h5>
      <p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来<br>
        使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器<br>
        的机制将库的标识符显式地导入到另外一个特定的作用域中。<br>
        这部分内容后续介绍
      </p>

    </article>
  <script>
    function foo() {

      function bar(a) {
        i = 3;            //修改for 循环所属作用域中的i
        console.log(i,a);
      }
      for(var i = 0;i<10;i++){
        bar(i);
      }

    }

    //foo();    
    //3 0 
    //3 4 
    //3 4 
    // ..
    
    

    

  </script>
</body>
</html>
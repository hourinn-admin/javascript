<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>作用域嵌套</title>
</head>
<body>
  <article>
    <h3>我们说过，作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。</h3>
    <p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
      或抵达最外层的作用域（也就是全局作用域）为止。</p>
    <p><b>考虑以下代码：</b><br>
    <pre><code>
      function foo(a) {
        console.log( a + b );
      }
      var b = 2;
      foo( 2 ); // 4</code></pre>
      对b 进行的RHS 引用无法在函数foo 内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。
    </p>
    
    <p>因此，回顾一下引擎和作用域之间的对话，会进一步听到：</p>
    <pre>
      引擎：foo 的作用域兄弟，你见过b 吗？我需要对它进行RHS 引用。
      作用域：听都没听过，走开。
      引擎：foo 的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过b 吗？我需要对它进行RHS 引用。
      作用域：当然了，给你吧。</pre>
    <p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>

  </article>
 
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>闭包初体验</title>
  <link rel="stylesheet" href="../css/code.css">
  </style>
</head>
<body>
  <article>
    
    <p>闭包一个神秘的概念,我们可以很容易的理解词法作用域,而闭包则是隐藏在代码之后的神秘阴影中,并不那么容易观察</p>
    <h4>直接了当的给出闭包的定义</h4>
    <p><b>当函数可以记住并访问它所在的词法作用域时,就产生了闭包,即使函数是在当前词法作用域之外执行</b></p>
    <div class="code">
      <pre>
        <code>
          function foo() {
            var a = 2;
            function bar() {
              console.log( a ); // 2
            }
            bar();
          }
          foo();
        </code>
      </pre>
    </div>
    <p>函数bar可以访问外部作用域的变量a,可以认为函数bar() 具有一个涵盖foo() 作用域的闭<br>
      包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）,为什么呢？原因简单明了，因为bar() 嵌套在foo() 内部。</p>

    <p>但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是<br>
      如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影<br>
      里，并不那么容易理解。</p>
    下面我们来看一段代码，清晰地展示了闭包：
    <div class="code">
      <pre>
        <code>
          function foo() {
            var a = 2;
            function bar() {
              console.log( a );
            }
            return bar;
          }
          var baz = foo();
          baz(); // 2 —— 朋友，这就是闭包的效果。
        </code>
      </pre>
    </div>
    <p>bar() 显然可以被正常执行。但是在这个例子中，它在自己所在的词法作用域(foo函数的词法作用域)以外的地方执行。</p>
    <p>在foo() 执行后，通常会期待foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃<br>
      圾回收器用来释放不再使用的内存空间。由于看上去foo() 的内容不会再被使用，所以很<br>
      自然地会考虑对其进行回收。</p>
    <p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上foo的内部作用域依然存在，因此
      没有被回收。谁在使用这个内部作用域？原来是bar() 本身在使用。</p>

    <p>拜bar() 所声明的位置所赐，它拥有涵盖foo() 内部作用域的闭包，使得该作用域能够一<br>
      直存活，以供bar() 在之后任何时间进行引用。</p>
    
    <p><b>bar() 持有对该作用域的引用，而这个引用就叫作闭包。</b></p>
   
    </article>
    <script>
    
    </script>
</body>
</html>
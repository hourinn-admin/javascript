<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>闭包应用之模块1</title>
  <link rel="stylesheet" href="../../css/code.css">
</head>
<body>
  <article>
    <h4>一个典型的模块例子</h4>
    <div style="height:300px;width:800px;background-color: gray;">
      <pre>
        <code>
          function CoolModule(){
            var something = "cool";
            var another = [1,2,3];
   
            function doSomething(){
              console.log(something);
            }
   
            function doAnother(){
              console.log(another.join("!"));
            }
   
            return {
              doSomething:doSomething,
              doAnother:doAnother
            }
          }
   
          var foo = CoolModule();
   
          foo.doSomething();
          foo.doAnother();
        </code>
      </pre>
    </div>

    <p>仔细分析上面代码：</p>

    <p>首先，CoolModule只是一个普通函数，必须通过调用它来创建一个模块实例(如果不执行外部函数，内部作用域和闭包都无法创建)</p>

    <p>其次，CoolModule()返回一个对象字面量语法{key：value,...}来表示的对象，这个对象中含有对内部函数而不是内部数据的引用。保持了内部数据变量是隐藏且私有的状态。<br>
      ,可以将这个对象类型的返回值看作模块的公共API。</p>
    
    <p>最后，通过将这个对象类型的返回值赋值给变量foo，然后就可以通过它来访问API中属性方法，比如foo.doSomething()</p>

    <h4>综合以上描述，模块模式需要两个必要条件</h4>
    <ol>
      <li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块
        实例）。</li>
      <li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并
        且可以访问或者修改私有的状态。</li>
    </ol>
    
   
    </article>


    <script>
       function CoolModule(){
         var something = "cool";
         var another = [1,2,3];

         function doSomething(){
           console.log(something);
         }

         function doAnother(){
           console.log(another.join("!"));
         }

         return {
           doSomething:doSomething,
           doAnother:doAnother
         }
       }

       var foo = CoolModule();

       foo.doSomething();
       foo.doAnother();
    </script>
</body>
</html>